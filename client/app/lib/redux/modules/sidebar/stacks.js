// Generated by CoffeeScript 1.10.0
var EDIT, GENERATE_STACK, INITIALIZE, LOAD, REMOVE, _, bongo, createSelector, defineSchema, destroyStack, draftStackTemplates, expandActionType, getMachineOwner, handleRoute, immutable, initializeStack, isAdmin, isStackTemplateSharedWithTeam, kd, makeNamespace, myStackTemplates, myStacks, normalize, openOnGitlab, privateStackTemplates, reducer, ref, ref1, ref2, reinitStack, reloadIDE, series, setAccess, sharedVMs, showError, sidebarStacks, stackProvider, stacksAndCredential, stacksAndMachines, stacksAndMenuItems, stacksAndTemplates, stacksRevisionStatus, teamStackTemplates, waterfall, whoami, withNamespace,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

kd = require('kd');

isAdmin = require('app/util/isAdmin');

immutable = require('app/util/immutable');

showError = require('app/util/showError');

whoami = require('app/util/whoami');

getMachineOwner = require('app/util/getMachineOwner');

isStackTemplateSharedWithTeam = require('app/util/isstacktemplatesharedwithteam');

ref = require('async'), series = ref.series, waterfall = ref.waterfall;

createSelector = require('reselect').createSelector;

ref1 = require('app/redux/helper'), makeNamespace = ref1.makeNamespace, expandActionType = ref1.expandActionType, normalize = ref1.normalize, defineSchema = ref1.defineSchema;

withNamespace = makeNamespace('koding', 'sidebar', 'stacks');

GENERATE_STACK = expandActionType(withNamespace('GENERATE_STACK'));

EDIT = expandActionType(withNamespace('EDIT'));

INITIALIZE = expandActionType(withNamespace('INITIALIZE'));

ref2 = require('app/redux/modules/bongo'), LOAD = ref2.LOAD, REMOVE = ref2.REMOVE;

bongo = require('app/redux/modules/bongo');

reducer = function(state, action) {
  var _id, data, error, ref3;
  if (state == null) {
    state = immutable({});
  }
  switch (action.type) {
    case 'STACK_REVISION_SUCCESS':
      console.log('haydaaaaaaa');
      ref3 = action.result, _id = ref3._id, data = ref3.data, error = ref3.error;
      if (error) {
        return state;
      }
      state = state.set(_id, immutable(data));
      return state;
    default:
      return state;
  }
};

initializeStack = function(template) {
  return function(dispatch) {
    var reactor;
    reactor = kd.singletons.reactor;
    return waterfall([
      function(next) {
        return dispatch({
          types: [LOAD.BEGIN, LOAD.SUCCESS, LOAD.FAIL],
          bongo: function() {
            return template.generateStack().then(function(result) {
              var instances, machines, ref3, stack;
              stack = result.stack, (ref3 = result.results, machines = ref3.machines);
              instances = machines.map(function(machine) {
                return machine.obj;
              });
              instances.push(stack);
              next(null, machines[0].obj);
              reactor.dispatch('GENERATE_STACK_SUCCESS', {
                template: template,
                stack: stack
              });
              return instances;
            });
          }
        });
      }, function(machine, next) {
        new kd.NotificationView({
          title: 'Stack generated successfully'
        });
        reloadIDE(machine.label);
        return next();
      }
    ]);
  };
};

openOnGitlab = function(stack) {
  var remoteUrl;
  remoteUrl = stack.getAt(['config', 'remoteDetails', 'originalUrl']);
  return kd.singletons.linkController.openOrFocus(remoteUrl);
};

handleRoute = function(route) {
  return kd.singletons.router.handleRoute(route);
};

setAccess = function(template) {
  if (!template) {
    return;
  }
  return {
    types: 'UPDATE',
    promise: function() {
      return new Promise(function(resolve, reject) {
        return template.setAccess('group', function(err) {
          if (!err) {
            return resolve();
          }
          return reject();
        });
      });
    }
  };
};

destroyStack = function(stack, machines, type) {
  var appManager, computeController, ref3;
  if (type == null) {
    type = 'deleteStack';
  }
  if (!stack) {
    return;
  }
  ref3 = kd.singletons, computeController = ref3.computeController, appManager = ref3.appManager;
  return {
    types: [REMOVE.BEGIN, REMOVE.SUCCESS, REMOVE.FAIL],
    promise: function() {
      return new Promise(function(resolve, reject) {
        return computeController.ui.askFor(type, {}, function(status) {
          if (!status.confirmed) {
            return;
          }
          return appManager.quitByName('IDE', function() {
            var followEvents;
            return computeController.destroyStack(stack, function(err) {
              var result;
              if (showError(err)) {
                return;
              }
              result = [];
              result.push(stack);
              machines.forEach(function(machine) {
                return result.push(machine);
              });
              handleRoute('/IDE');
              return resolve(result);
            }, followEvents = false);
          });
        });
      });
    }
  };
};

reloadIDE = function(machineSlug) {
  var computeController;
  computeController = kd.singletons.computeController;
  return computeController.reloadIDE(machineSlug);
};

reinitStack = function(stack, machines, template) {
  return function(dispatch) {
    var appManager, computeController, ref3;
    if (!(template || !stack)) {
      return;
    }
    ref3 = kd.singletons, computeController = ref3.computeController, appManager = ref3.appManager;
    return series([
      function(next) {
        return dispatch(destroyStack(stack, machines, 'reinitStack')).then(function() {
          return next();
        });
      }, function(next) {
        return initializeStack(template)(dispatch);
      }
    ]);
  };
};

myStackTemplates = createSelector(bongo.all('JStackTemplate'), function(templates) {
  return _.pickBy(templates, function(template) {
    return template.originId === whoami()._id;
  });
});

myStacks = createSelector(bongo.all('JComputeStack'), function(stacks) {
  return _.pickBy(stacks, function(stack) {
    console.log('GIRMEDIM');
    return stack.originId === whoami()._id;
  });
});

privateStackTemplates = createSelector(myStackTemplates, function(templates) {
  return templates && _.values(templates).filter(function(template) {
    return template.accessLevel === 'private';
  });
});

teamStackTemplates = createSelector(myStackTemplates, function(templates) {
  return templates && _.values(templates).filter(function(template) {
    return template.accessLevel === 'group';
  });
});

draftStackTemplates = createSelector(myStacks, myStackTemplates, function(stacks, templates) {
  var baseStackIds;
  if (!(stacks && templates)) {
    return null;
  }
  console.log('templates', templates);
  console.log('stacks ', stacks);
  baseStackIds = _.values(stacks).map(function(s) {
    return s.baseStackId;
  });
  return _.pickBy(templates, function(template) {
    var ref3;
    return !(ref3 = template._id, indexOf.call(baseStackIds, ref3) >= 0);
  });
});

sidebarStacks = createSelector(myStacks, draftStackTemplates, function(stacks, templates) {
  if (!(stacks && templates)) {
    return null;
  }
  console.log('???> ', stacks);
  console.log('???>> ', templates);
  return _.merge(stacks, templates);
});

stacksAndMachines = createSelector(sidebarStacks, bongo.all('JMachine'), function(stacks, machines) {
  if (!(stacks && machines)) {
    return null;
  }
  return _.mapValues(stacks, function(stack, key) {
    return stack.machines.map(function(machineId) {
      return machines[machineId];
    }).filter(Boolean);
  });
});

stacksAndTemplates = createSelector(sidebarStacks, myStackTemplates, function(stacks, templates) {
  if (!(stacks && templates)) {
    return null;
  }
  return _.mapValues(stacks, function(stack, key) {
    if (stack.baseStackId) {
      return templates[stack.baseStackId];
    } else {
      return stack;
    }
  });
});

stacksAndCredential = createSelector(sidebarStacks, bongo.all('JCredential'), function(stacks, credentials) {
  console.log('<<< stacks', stacks);
  return _.mapValues(stacks, function(stack, key) {
    var provider;
    provider = stackProvider(stack);
    return _.values(credentials).filter(function(credential) {
      var ref3, ref4;
      console.log('sacma');
      return ((ref3 = stack.credentials) != null ? (ref4 = ref3["" + provider]) != null ? ref4.first : void 0 : void 0) === credential.identifier;
    });
  });
});

stacksAndMenuItems = createSelector(sidebarStacks, function(stacks) {
  console.log('menuItems ', stacks);
  return _.mapValues(stacks, function(stack, key) {
    var managedVM, menuItems, ref3, revision;
    menuItems = {};
    console.log('> stack ***', stack);
    if (stack.bongo_.constructorName === 'JComputeStack') {
      revision = typeof status !== "undefined" && status !== null ? status[stack._id] : void 0;
      if (revision != null ? (ref3 = revision.status) != null ? ref3.code : void 0 : void 0) {
        menuItems['Update'] = null;
      }
      managedVM = stack.title.indexOf('Managed VMs') > -1;
      if (managedVM) {
        menuItems['VMs'] = null;
      } else {
        if (isAdmin() && !stack.config.oldOwner) {
          menuItems['Edit'] = null;
        }
        if (!stack.config.oldOwner) {
          menuItems['Reinitialize'] = null;
        }
        ['VMs', 'Destroy VMs'].forEach(function(name) {
          return menuItems[name] = null;
        });
        if (isAdmin() && !isStackTemplateSharedWithTeam(stack.baseStackId)) {
          menuItems['Make Team Default'] = null;
        }
      }
    } else {
      ['Edit', 'Initialize'].forEach(function(name) {
        return menuItems[name] = null;
      });
      if (isAdmin() && !stack.baseStackId) {
        menuItems['Make Team Default'] = null;
      }
    }
    console.log('*******', {
      menuItems: menuItems
    });
    return menuItems;
  });
});

stackProvider = function(stack) {
  var config, credentials, i, len, requiredProviders, selectedProvider;
  config = stack.config, credentials = stack.credentials;
  if (!config) {
    return 'managedVM';
  }
  requiredProviders = config.requiredProviders;
  for (i = 0, len = requiredProviders.length; i < len; i++) {
    selectedProvider = requiredProviders[i];
    if (selectedProvider === 'aws' || selectedProvider === 'vagrant') {
      break;
    }
  }
  if (selectedProvider == null) {
    selectedProvider = (Object.keys(credentials != null ? credentials : {
      aws: true
    })).first;
  }
  if (selectedProvider == null) {
    selectedProvider = 'aws';
  }
  return selectedProvider;
};

stacksRevisionStatus = function(state) {
  console.log('stacksRevisionStatus', state);
  return state.stacksAndRevisions;
};

sharedVMs = createSelector(bongo.all('JMachine'), function(machines) {
  return _.values(machines).filter(function(machine) {
    var nickname, ownerNickname;
    if (!(machine.users.length > 1)) {
      return false;
    }
    nickname = whoami().profile.nickname;
    ownerNickname = getMachineOwner(machine, true);
    return nickname !== ownerNickname;
  });
});

module.exports = _.assign(reducer, {
  namespace: withNamespace(),
  reducer: reducer,
  initializeStack: initializeStack,
  openOnGitlab: openOnGitlab,
  handleRoute: handleRoute,
  destroyStack: destroyStack,
  reinitStack: reinitStack,
  reloadIDE: reloadIDE,
  setAccess: setAccess,
  stacksAndMachines: stacksAndMachines,
  stacksAndMenuItems: stacksAndMenuItems,
  stacksAndTemplates: stacksAndTemplates,
  stacksAndCredential: stacksAndCredential,
  sharedVMs: sharedVMs,
  sidebarStacks: sidebarStacks
});
